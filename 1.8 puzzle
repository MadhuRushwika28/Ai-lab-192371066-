from collections import deque

goal = (1,2,3,4,5,6,7,8,0)

def neighbors(state):
    zero = state.index(0)
    moves = []
    for delta in [-3,3,-1,1]:
        new_pos = zero + delta
        if 0 <= new_pos < 9:
            # Avoid invalid left-right moves
            if zero % 3 == 0 and delta == -1: continue
            if zero % 3 == 2 and delta == 1: continue
            new_state = list(state)
            new_state[zero], new_state[new_pos] = new_state[new_pos], new_state[zero]
            moves.append(tuple(new_state))
    return moves

def bfs(start):
    queue = deque([start])
    visited = {start: None}
    while queue:
        state = queue.popleft()
        if state == goal:
            path = []
            while state:
                path.append(state)
                state = visited[state]
            return path[::-1]
        for n in neighbors(state):
            if n not in visited:
                visited[n] = state
                queue.append(n)
    return None

start = (1,2,3,4,0,5,7,8,6)
path = bfs(start)
if path:
    print(f"Solved in {len(path)-1} moves:")
    for p in path:
        print(p[:3])
        print(p[3:6])
        print(p[6:])
        print()
else:
    print("No solution found.")
